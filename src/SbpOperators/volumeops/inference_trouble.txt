Innan ändringarna på den här branchen:

begin
    using Sbplib
    using Sbplib.Grids
    using Sbplib.SbpOperators

    g = EquidistantGrid((10,10),(0.,0.), (1.,1.))
    v = evalOn(g, (x,y)->x^2+y^2+1)
    H = inner_product(g, 1., [1/2])
end

# Not type stable
LazyTensors.apply(H.t1, H.t2*v, 1,2) 
@code_warntype LazyTensors.apply(H.t1, H.t2*v, 1,2)
@code_warntype LazyTensors.apply(H.t1.tm, view(H.t2*v,:,1), 2)

# Nedan är halvdåliga
@code_warntype LazyTensors.apply(H.t1.tm, view(H.t2*v,1,:), 2)
@code_warntype LazyTensors.apply(H.t1.tm, view(v,1,:), 2)
@code_warntype LazyTensors.apply(H.t1.tm, view(v,:,1), 2)
@code_warntype LazyTensors.apply(H.t1.tm, v[:,1], 2)









begin
    using Sbplib
    using Sbplib.Grids
    using Sbplib.SbpOperators
    import Sbplib.SbpOperators: Stencil
    using Sbplib.RegionIndices

    g = EquidistantGrid(10,0., 1.)
    v = evalOn(g, (x)->x^2+1)
    H = inner_product(g, 1., [1/2])
    V = SbpOperators.volume_operator(g, Stencil(1.,center=1), (Stencil(1/2,center=1),), SbpOperators.even,1)
    b = SbpOperators.boundary_operator(g, Stencil(1/2,center=1), CartesianBoundary{1,Lower}())
end

@code_warntype LazyTensors.apply(H, H*v, 2)
@code_warntype LazyTensors.apply(V, V*v, 2)
@code_warntype LazyTensors.apply(b, b*v, 2)



begin
end
